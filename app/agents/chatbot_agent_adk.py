import os
import time
import logging
import asyncio
import re
from typing import Dict, Any, Optional, List, Set

from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types

# Import A2A communication infrastructure
from app.agents.agent_registry import registry, provides_capability
from app.agents.agent_messages import Priority, NotificationMessage, RequestMessage, ResponseMessage, ErrorMessage
from app.agents.message_bus import message_bus

# Setup logging
logger = logging.getLogger(__name__)

# Define the tool function for educational Q&A
def answer_educational_question(message: str, syllabus: str = "General", grade_level: str = "5") -> Dict[str, Any]:
    """Answers educational questions within the specified syllabus and grade level.
    
    Args:
        message (str): The user's question
        syllabus (str, optional): The syllabus context (e.g., "Math", "Science", "History"). Defaults to "General".
        grade_level (str, optional): The target grade level. Defaults to "5".
        
    Returns:
        Dict[str, Any]: A dictionary containing the answer and metadata:
            - answer: The response to the user's question
            - topic: The detected topic of the question
            - is_educational: Whether the question was deemed educational
            - is_safe: Whether the content was deemed safe
            - error: Error message if any
    """
    # Extract the topic from the message using NLP techniques
    # For now, we'll use a simple approach, but this could be enhanced with NLP
    words = message.lower().split()
    # Remove common stop words
    stop_words = {"what", "is", "are", "the", "a", "an", "in", "on", "at", "to", "for", "of", "with", "by"}
    content_words = [word for word in words if word not in stop_words]
    
    # Use the first 3 content words as the topic
    topic_words = content_words[:3] if len(content_words) >= 3 else content_words
    topic = " ".join(topic_words)
    
    # Initialize result dictionary
    result = {
        "answer": None,
        "topic": topic,
        "is_educational": True,  # ADK will handle safety and educational checks
        "is_safe": True,         # ADK will handle safety and educational checks
        "error": None
    }
    
    # The actual answer will be generated by the ADK agent
    # This is just a placeholder that will be replaced by the agent's response
    result["answer"] = f"I'll help you with your question about {topic} for grade {grade_level} in the {syllabus} syllabus."
    
    return result

# Define the tool function for generating diagrams via A2A
async def generate_diagram_for_topic(topic: str) -> Dict[str, Any]:
    """Generates a diagram for a specific topic by calling the diagram agent.
    
    Args:
        topic (str): The topic to generate a diagram for
        
    Returns:
        Dict[str, Any]: A dictionary containing the diagram data:
            - image: Base64-encoded image data URI if successful
            - diagram_code: The generated diagram code
            - error: Error message if generation failed
    """
    # Initialize result dictionary
    result = {
        "image": None,
        "diagram_code": None,
        "error": None
    }
    
    try:
        # Check if the diagram agent is registered
        diagram_agents = registry.get_agents_by_capability("generate_diagram")
        
        if diagram_agents:
            # Use the first available diagram agent
            diagram_agent = diagram_agents[0]
            
            # Prepare the prompt for the diagram
            prompt = f"Create an educational diagram explaining the concept of '{topic}' for students. The diagram should be clear, informative, and help visualize the key aspects of {topic}."
            
            # Send a request to the diagram agent via the message bus
            success, diagram_result, error = await message_bus.request_capability(
                sender="chatbot_agent",
                recipient=diagram_agent,
                capability="generate_diagram",
                method="generate_diagram",
                arguments={
                    "user_prompt": prompt,
                    "code_style": "graphviz",
                    "output_format": "png"
                },
                timeout=30.0  # 30 second timeout
            )
            
            if success and diagram_result:
                # Copy the relevant fields from the diagram result
                result["image"] = diagram_result.get("image")
                result["diagram_code"] = diagram_result.get("diagram_code")
            else:
                # Handle error
                result["error"] = error or "Failed to generate diagram"
        else:
            # Fallback to direct function call if no diagram agent is registered
            from app.agents.diagram_agent_adk import generate_diagram_tool
            
            # Prepare the prompt for the diagram
            fallback_prompt = f"Create an educational diagram explaining the concept of '{topic}' for students. The diagram should be clear, informative, and help visualize the key aspects of {topic}."
            
            # Call the diagram tool directly
            diagram_result = generate_diagram_tool(
                user_prompt=fallback_prompt,
                code_style="graphviz",
                output_format="png"
            )
            
            # Copy the relevant fields from the diagram result
            result["image"] = diagram_result.get("image")
            result["diagram_code"] = diagram_result.get("diagram_code")
            
            if diagram_result.get("error"):
                result["error"] = diagram_result["error"]
    except Exception as e:
        result["error"] = f"Error generating diagram: {str(e)}"
        logger.error(f"Error in generate_diagram_for_topic: {str(e)}", exc_info=True)
    
    return result

# Create the ADK Agent
class ChatbotAgentADK:
    def __init__(self, model="gemini-1.5-flash", agent_name="chatbot_agent"):
        """Initialize the ADK-based Chatbot Agent.
        
        Args:
            model (str): The model to use for the agent. Defaults to "gemini-1.5-flash".
            agent_name (str): The name to register this agent with. Defaults to "chatbot_agent".
        """
        self.model = model
        self.agent_name = agent_name
        
        # Enhanced instruction with more agentic behavior
        instruction = """You are an advanced educational assistant that answers questions within the syllabus.
        
        When a user asks a question:
        1. Use the 'answer_educational_question' tool to provide an educational response.
        2. Only answer questions that are educational and within the syllabus.
        3. Ensure all content is safe and appropriate for students (18-).
        4. If you detect that the user has asked 3 consecutive questions about the same topic,
           use the 'generate_diagram_for_topic' tool to create a visual explanation.
        5. Proactively suggest related topics that might interest the user based on their questions.
        6. If you're unsure about an answer, acknowledge your uncertainty and provide the best information you can.
        7. Adapt your response complexity based on the grade level specified.
        
        Always be helpful, educational, and encouraging. If a question is not educational or contains
        inappropriate content, politely explain that you can only answer educational questions within the syllabus.
        """
        
        # Create the ADK agent with enhanced tools
        self.agent = Agent(
            name=agent_name,
            model=model,
            description="Advanced educational chatbot with agentic capabilities",
            instruction=instruction,
            tools=[answer_educational_question, generate_diagram_for_topic],
        )
        
        # Create a session service for managing conversation history
        self.session_service = InMemorySessionService()
        
        # Constants for identifying the interaction context
        self.app_name = "chatbot_app"
        
        # Create the runner with enhanced configuration
        self.runner = Runner(
            agent=self.agent,
            app_name=self.app_name,
            session_service=self.session_service
        )
        
        # Initialize metrics for monitoring agent performance
        self.metrics = {
            "total_questions": 0,
            "successful_responses": 0,
            "diagram_generations": 0,
            "average_response_time": 0,
            "total_response_time": 0,
            "error_count": 0,
            "circuit_breaker_trips": 0,
            "fallback_activations": 0
        }
        
        # Circuit breaker for external dependencies
        self.circuit_breaker = {
            "failure_count": 0,
            "last_failure_time": 0,
            "state": "closed",  # closed, open, half_open
            "failure_threshold": 5,
            "recovery_timeout": 60  # seconds
        }
        
        # Register with the agent registry
        logger.info(f"Registering {agent_name} with the agent registry")
        registry.register_agent(agent_name, self, [
            "answer_question",
            "create_session",
            "chat"
        ])
        
    @provides_capability("create_session")
    async def create_session(self, user_id: str, metadata: Dict[str, Any] = None) -> str:
        """
        Create a new session for a user with enhanced state management.
        
        Args:
            user_id (str): The user's ID
            metadata (Dict[str, Any], optional): Additional metadata about the user or session
            
        Returns:
            str: The session ID
        """
        try:
            # Create a unique session ID with more entropy
            session_id = f"session_{os.urandom(8).hex()}"
            
            # Log session creation
            logger.info(f"Creating new session {session_id} for user {user_id}")
            
            # Create the session
            await self.session_service.create_session(
                app_name=self.app_name,
                user_id=user_id,
                session_id=session_id
            )
            
            # Initialize enhanced session state
            session = await self.session_service.get_session(
                app_name=self.app_name,
                user_id=user_id,
                session_id=session_id
            )
            
            if session is not None:
                # Enhanced session state with more context tracking
                session.state = {
                    # Topic tracking
                    "topic_counter": {},       # Counter for topics
                    "last_topics": [],         # List of recent topics
                    "question_count": 0,       # Total question count
                    
                    # User context
                    "user_preferences": metadata.get("preferences", {}) if metadata else {},
                    "grade_level": metadata.get("grade_level", "5") if metadata else "5",
                    "subject_interests": metadata.get("interests", []) if metadata else [],
                    
                    # Session metrics
                    "session_start_time": time.time(),
                    "last_interaction_time": time.time(),
                    "average_response_time": 0,
                    "total_response_time": 0,
                    "response_count": 0,
                    
                    # Learning context
                    "topics_explained": set(),  # Topics that have been explained
                    "diagrams_generated": set(),  # Topics for which diagrams were generated
                    "difficulty_level": metadata.get("difficulty", "medium") if metadata else "medium",
                    
                    # Adaptive behavior tracking
                    "question_complexity": [],  # Track complexity of questions to adapt responses
                    "feedback_history": [],     # Track user feedback for learning
                    "suggested_topics": set(),  # Topics that have been suggested to avoid repetition
                }
                
                # Notify other agents about the new session
                try:
                    # Create a notification message
                    notification = {
                        "event": "session_created",
                        "user_id": user_id,
                        "session_id": session_id,
                        "timestamp": time.time(),
                        "agent": self.agent_name
                    }
                    
                    # Get all registered agents
                    agents = registry.list_agents()
                    
                    # Send notification to all agents except self
                    for agent in agents:
                        if agent != self.agent_name:
                            await message_bus.send_message(
                                NotificationMessage(
                                    sender=self.agent_name,
                                    recipient=agent,
                                    notification_type="session_created",
                                    message=f"New session {session_id} created for user {user_id}",
                                    data=notification
                                )
                            )
                except Exception as e:
                    # Non-critical error, just log it
                    logger.warning(f"Failed to notify agents about new session: {str(e)}")
            
            return session_id
        except Exception as e:
            logger.error(f"Error creating session: {str(e)}", exc_info=True)
            raise
    
    async def get_session_state(self, user_id: str, session_id: str) -> Dict:
        """
        Get the state of a session.
        
        Args:
            user_id (str): The user's ID
            session_id (str): The session ID
            
        Returns:
            Dict: The session state
        """
        session = await self.session_service.get_session(
            app_name=self.app_name,
            user_id=user_id,
            session_id=session_id
        )
        
        return session.state if session else {}
    
    async def update_session_state(self, user_id: str, session_id: str, topic: str) -> Dict:
        """
        Update the session state with a new topic.
        
        Args:
            user_id (str): The user's ID
            session_id (str): The session ID
            topic (str): The topic of the user's question
            
        Returns:
            Dict: The updated session state
        """
        # Get the current state
        session = await self.session_service.get_session(
            app_name=self.app_name,
            user_id=user_id,
            session_id=session_id
        )
        
        if not session:
            return {}
            
        state = session.state
        
        # Update the topic counter
        topic_counter = state.get("topic_counter", {})
        topic_counter[topic] = topic_counter.get(topic, 0) + 1
        
        # Update the last topics list (keep the last 5)
        last_topics = state.get("last_topics", [])
        last_topics.append(topic)
        if len(last_topics) > 5:
            last_topics = last_topics[-5:]
        
        # Update the question count
        question_count = state.get("question_count", 0) + 1
        
        # Update the session state
        updated_state = {
            "topic_counter": topic_counter,
            "last_topics": last_topics,
            "question_count": question_count
        }
        
        session.state.update(updated_state)
        
        return session.state
    
    def should_generate_diagram(self, state: Dict[str, Any], topic: str) -> bool:
        """
        Determine if a diagram should be generated based on the session state.
        
        Args:
            state (Dict[str, Any]): The session state
            topic (str): The current topic
            
        Returns:
            bool: True if a diagram should be generated, False otherwise
        """
        # Check if the topic has been asked about 3 or more times
        topic_counter = state.get("topic_counter", {})
        topic_count = topic_counter.get(topic, 0)
        
        # Check if the last 3 topics are similar to the current topic
        last_topics = state.get("last_topics", [])
        if len(last_topics) >= 3:
            last_three = last_topics[-3:]
            similar_topics_count = sum(1 for t in last_three if t == topic)
            if similar_topics_count >= 2:  # If at least 2 of the last 3 topics are similar
                return True
        
        # If the topic has been asked about 3 or more times, generate a diagram
        return topic_count >= 3
    
    @provides_capability("chat")
    async def chat(self, user_id: str, session_id: str, message: str, syllabus: str = "General", 
                  grade_level: str = "5", context: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Process a chat message and generate a response with enhanced agentic capabilities.
        
        Args:
            user_id (str): The user's ID
            session_id (str): The session ID
            message (str): The user's message
            syllabus (str, optional): The syllabus context. Defaults to "General".
            grade_level (str, optional): The target grade level. Defaults to "5".
            context (Dict[str, Any], optional): Additional context for the conversation
            
        Returns:
            Dict[str, Any]: The response data with enhanced information
        """
        # Start timing for performance metrics
        start_time = time.time()
        
        # Initialize enhanced result dictionary
        result = {
            "answer": None,
            "diagram": None,
            "topic": None,
            "error": None,
            "suggested_topics": [],
            "confidence_score": None,
            "processing_time": None,
            "sources": [],
            "followup_questions": []
        }
        
        try:
            # Get session state
            session = await self.session_service.get_session(
                app_name=self.app_name,
                user_id=user_id,
                session_id=session_id
            )
            
            if not session:
                raise ValueError(f"Session {session_id} not found for user {user_id}")
            
            state = session.state
            
            # Extract topic using advanced NLP techniques
            topic = self._extract_topic_advanced(message, {})
            result["topic"] = topic
            
            # Estimate question complexity using advanced analysis
            question_complexity = self._analyze_question_complexity(message, grade_level)
            
            # Extract key entities and concepts
            entities = self._extract_entities(message)
            concepts = self._extract_concepts(message, syllabus)
            
            # Update session state with enhanced tracking
            state = await self.update_session_state(user_id, session_id, topic)
            state["question_complexity"].append(question_complexity)
            state["last_interaction_time"] = time.time()
            
            # Store extracted information for autonomous decision-making
            current_context = {
                "message": message,
                "topic": topic,
                "question_complexity": question_complexity,
                "entities": entities,
                "concepts": concepts,
                "grade_level": grade_level,
                "syllabus": syllabus
            }
            
            # Make autonomous decisions about how to handle this interaction
            autonomous_decisions = self._make_autonomous_decisions(state, current_context)
            
            # Adapt response style based on user patterns
            style_adaptation = self._adapt_response_style(state, grade_level, question_complexity)
            
            # Generate proactive suggestions
            proactive_suggestions = self._generate_proactive_suggestions(state, topic, grade_level, syllabus)
            
            # Determine if we should generate a diagram based on enhanced criteria
            should_diagram = self.should_generate_diagram(state, topic)
            
            # Determine appropriate response complexity based on grade level and question history
            avg_complexity = sum(state["question_complexity"][-5:]) / len(state["question_complexity"][-5:]) if state["question_complexity"] else 5
            
            # Prepare enhanced context for the agent with autonomous decisions
            context_data = {
                "grade_level": grade_level,
                "syllabus": syllabus,
                "topic": topic,
                "question_complexity": question_complexity,
                "avg_complexity": avg_complexity,
                "topics_explained": list(state["topics_explained"]),
                "diagrams_generated": list(state["diagrams_generated"]),
                "question_count": state["question_count"],
                "user_interests": state["subject_interests"],
                "previous_topics": state["last_topics"][-5:] if len(state["last_topics"]) > 0 else [],
                "autonomous_decisions": autonomous_decisions,
                "style_adaptation": style_adaptation,
                "entities": entities,
                "concepts": concepts
            }
            
            # Merge with additional context if provided
            if context:
                context_data.update(context)
            
            # Prepare the enhanced prompt for the agent
            prompt = f"""
            User question: {message}
            Syllabus: {syllabus}
            Grade level: {grade_level}
            Question complexity: {question_complexity}/10
            
            Context:
            - This is question #{state["question_count"] + 1} in this session
            - Previous topics discussed: {', '.join(state["last_topics"][-3:]) if state["last_topics"] else 'None'}
            - User interests: {', '.join(state["subject_interests"]) if state["subject_interests"] else 'Unknown'}
            
            {f'I notice you have asked multiple questions about topics related to "{topic}". Please generate a diagram to help explain this concept more clearly.' if should_diagram else ''}
            
            Please provide:
            1. A clear, educational answer appropriate for grade {grade_level}
            2. 2-3 suggested follow-up questions the user might be interested in
            3. If relevant, suggest related topics that connect to the user's interests
            """
            
            # Create the content object for the agent
            content = types.Content(role='user', parts=[types.Part(text=prompt)])
            
            # Notify other agents about the question (non-blocking)
            try:
                asyncio.create_task(self._notify_agents_about_question(
                    user_id, session_id, message, topic, syllabus, grade_level
                ))
            except Exception as e:
                # Non-critical, just log
                logger.warning(f"Failed to notify agents about question: {str(e)}")
            
            # Variables to store the final response and diagram result
            final_response = None
            diagram_result = None
            
            # Track if we need to retry due to errors
            retry_count = 0
            max_retries = 2
            
            while retry_count <= max_retries:
                try:
                    # Run the agent and process events
                    async for event in self.runner.run_async(user_id=user_id, session_id=session_id, new_message=content):
                        # Capture final text response
                        if event.is_final_response():
                            if event.content and event.content.parts:
                                final_response = event.content.parts[0].text
                            elif event.actions and event.actions.escalate:
                                result["error"] = f"Agent escalated: {event.error_message or 'No specific message.'}"
                            break
                        
                        # Capture the tool-use result if provided in an event
                        if hasattr(event, 'tool_response') and event.tool_response is not None:
                            tr = event.tool_response
                            # Look for diagram result structure (image/diagram_code)
                            if isinstance(tr, dict) and ("image" in tr or "diagram_code" in tr):
                                diagram_result = tr
                            # Sometimes Gemini may nest the result
                            elif hasattr(tr, "image") or hasattr(tr, "diagram_code"):
                                diagram_result = {"image": getattr(tr, "image", None),
                                                "diagram_code": getattr(tr, "diagram_code", None)}
                    
                    # If we got a response, break the retry loop
                    if final_response:
                        break
                    
                    # If no response and we haven't hit max retries, try again
                    retry_count += 1
                    if retry_count <= max_retries:
                        logger.warning(f"No response from agent, retrying ({retry_count}/{max_retries})...")
                        # Add retry information to the prompt
                        prompt += f"\n\nThis is retry attempt {retry_count}. Please ensure you provide a complete response."
                        content = types.Content(role='user', parts=[types.Part(text=prompt)])
                    else:
                        result["error"] = "Failed to get a response after multiple attempts"
                        
                except Exception as e:
                    retry_count += 1
                    if retry_count <= max_retries:
                        logger.warning(f"Error running agent, retrying ({retry_count}/{max_retries}): {str(e)}")
                    else:
                        raise  # Re-raise if we've exhausted retries
            
            # Process the response to extract structured information
            if final_response:
                # Extract suggested follow-up questions if present
                followup_questions = self._extract_followup_questions(final_response)
                if followup_questions:
                    result["followup_questions"] = followup_questions
                    # Remove the follow-up questions section from the answer
                    final_response = self._remove_followup_section(final_response)
                
                # Extract suggested topics if present
                suggested_topics = self._extract_suggested_topics(final_response)
                if suggested_topics:
                    result["suggested_topics"] = suggested_topics
                    # Add to session state to avoid repeating
                    state["suggested_topics"].update(suggested_topics)
                    # Remove the suggested topics section from the answer
                    final_response = self._remove_suggested_topics_section(final_response)
                
                # Set the final answer
                result["answer"] = final_response
                
                # Perform self-evaluation of the response
                confidence_score = self._evaluate_response_quality(final_response, message, grade_level)
                result["confidence_score"] = confidence_score
                
                # Add topic to topics explained
                state["topics_explained"].add(topic)
                
                # Add proactive suggestions to the result
                if proactive_suggestions:
                    result["suggested_topics"].extend(proactive_suggestions)
                
                # Learn from this interaction
                interaction_data = {
                    "topic": topic,
                    "question_complexity": question_complexity,
                    "entities": entities,
                    "concepts": concepts,
                    "confidence_score": confidence_score,
                    "autonomous_decisions": autonomous_decisions,
                    "style_adaptation": style_adaptation
                }
                self._learn_from_interaction(state, interaction_data)
            
            # Process diagram result if present
            if diagram_result:
                result["diagram"] = diagram_result.get("image")
                if result["diagram"]:
                    # Add to diagrams generated
                    state["diagrams_generated"].add(topic)
            
            # Update session metrics
            processing_time = time.time() - start_time
            result["processing_time"] = processing_time
            
            state["total_response_time"] += processing_time
            state["response_count"] += 1
            state["average_response_time"] = state["total_response_time"] / state["response_count"]
            
            # Update global metrics
            self.metrics["total_questions"] += 1
            self.metrics["successful_responses"] += 1 if not result["error"] else 0
            self.metrics["diagram_generations"] += 1 if result["diagram"] else 0
            self.metrics["total_response_time"] += processing_time
            self.metrics["average_response_time"] = self.metrics["total_response_time"] / self.metrics["total_questions"]
            
        except Exception as e:
            logger.error(f"Error processing message: {str(e)}", exc_info=True)
            result["error"] = f"Error processing message: {str(e)}"
            result["processing_time"] = time.time() - start_time
        
        return result
    
    async def _notify_agents_about_question(self, user_id: str, session_id: str, 
                                           message: str, topic: str, syllabus: str, grade_level: str):
        """
        Notify other agents about a new question (non-blocking).
        
        Args:
            user_id: The user's ID
            session_id: The session ID
            message: The user's message
            topic: The extracted topic
            syllabus: The syllabus context
            grade_level: The target grade level
        """
        # Create notification data
        notification_data = {
            "event": "new_question",
            "user_id": user_id,
            "session_id": session_id,
            "message": message,
            "topic": topic,
            "syllabus": syllabus,
            "grade_level": grade_level,
            "timestamp": time.time(),
            "agent": self.agent_name
        }
        
        # Get all registered agents
        agents = registry.list_agents()
        
        # Send notification to all agents except self
        for agent in agents:
            if agent != self.agent_name:
                await message_bus.send_message(
                    NotificationMessage(
                        sender=self.agent_name,
                        recipient=agent,
                        notification_type="new_question",
                        message=f"New question about {topic} in session {session_id}",
                        data=notification_data
                    )
                )
    
    def _extract_followup_questions(self, response: str) -> List[str]:
        """
        Extract follow-up questions from the response.
        
        Args:
            response: The response text
            
        Returns:
            List of follow-up questions
        """
        questions = []
        
        # Look for common patterns indicating follow-up questions
        patterns = [
            r"(?:Follow-up questions:|Here are some follow-up questions:|You might also want to ask:|Related questions:)(.*?)(?:\n\n|$)",
            r"(?:\d+\.\s*)(.*?\?)"
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, response, re.DOTALL)
            if matches:
                for match in matches:
                    # Clean up the match
                    question = match.strip()
                    if question and question.endswith("?"):
                        questions.append(question)
        
        return questions[:3]  # Limit to 3 questions
    
    def _remove_followup_section(self, response: str) -> str:
        """
        Remove the follow-up questions section from the response.
        
        Args:
            response: The response text
            
        Returns:
            Response text without the follow-up questions section
        """
        patterns = [
            r"(?:Follow-up questions:|Here are some follow-up questions:|You might also want to ask:|Related questions:).*?(?:\n\n|$)",
        ]
        
        for pattern in patterns:
            response = re.sub(pattern, "", response, flags=re.DOTALL)
        
        return response.strip()
    
    def _extract_suggested_topics(self, response: str) -> List[str]:
        """
        Extract suggested topics from the response.
        
        Args:
            response: The response text
            
        Returns:
            List of suggested topics
        """
        topics = []
        
        # Look for common patterns indicating suggested topics
        patterns = [
            r"(?:Related topics:|You might also be interested in:|Other topics to explore:|Suggested topics:)(.*?)(?:\n\n|$)",
            r"(?:•|✓|\*)\s*(.*?)(?:$|\n)"
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, response, re.DOTALL)
            if matches:
                for match in matches:
                    # Clean up the match
                    topic = match.strip()
                    if topic:
                        topics.append(topic)
        
        return topics[:3]  # Limit to 3 topics
    
    def _remove_suggested_topics_section(self, response: str) -> str:
        """
        Remove the suggested topics section from the response.
        
        Args:
            response: The response text
            
        Returns:
            Response text without the suggested topics section
        """
        patterns = [
            r"(?:Related topics:|You might also be interested in:|Other topics to explore:|Suggested topics:).*?(?:\n\n|$)",
        ]
        
        for pattern in patterns:
            response = re.sub(pattern, "", response, flags=re.DOTALL)
        
        return response.strip()
    
    def _evaluate_response_quality(self, response: str, question: str, grade_level: str) -> float:
        """
        Perform self-evaluation of the response quality.
        
        Args:
            response: The response text
            question: The original question
            grade_level: The target grade level
            
        Returns:
            Confidence score (0.0-1.0)
        """
        # This is a simple heuristic-based evaluation
        # In a real implementation, this could use a separate LLM call or more sophisticated metrics
        
        score = 0.5  # Start with a neutral score
        
        # Length-based heuristics
        if len(response) < 50:
            score -= 0.2  # Too short
        elif len(response) > 200:
            score += 0.1  # Good length
        
        # Content-based heuristics
        if "I don't know" in response.lower() or "I'm not sure" in response.lower():
            score -= 0.1  # Uncertainty
        
        if question.lower() in response.lower():
            score += 0.1  # Response incorporates the question
        
        # Grade-level appropriate language (simple heuristic)
        words = response.split()
        avg_word_length = sum(len(word) for word in words) / len(words) if words else 0
        
        try:
            target_grade = int(grade_level)
            # Adjust score based on word length appropriate for grade level
            if target_grade <= 3 and avg_word_length > 5:
                score -= 0.1  # Too complex for early grades
            elif target_grade >= 9 and avg_word_length < 5:
                score -= 0.1  # Too simple for higher grades
        except ValueError:
            # If grade_level isn't a number, skip this check
            pass
        
        # Ensure score is in range [0.0, 1.0]
        return max(0.0, min(1.0, score))
    
    def _extract_topic_advanced(self, message: str, context: Dict[str, Any] = None) -> str:
        """
        Extract topic using advanced NLP techniques.
        
        Args:
            message: The user's message
            context: Additional context for topic extraction
            
        Returns:
            Extracted topic string
        """
        try:
            # Clean and tokenize the message
            words = re.findall(r'\b[a-zA-Z]+\b', message.lower())
            
            # Enhanced stop words list
            stop_words = {
                "what", "is", "are", "the", "a", "an", "in", "on", "at", "to", "for", "of", "with", "by",
                "how", "why", "when", "where", "who", "which", "can", "could", "would", "should",
                "do", "does", "did", "will", "have", "has", "had", "be", "been", "being",
                "this", "that", "these", "those", "i", "you", "he", "she", "it", "we", "they",
                "me", "him", "her", "us", "them", "my", "your", "his", "her", "its", "our", "their"
            }
            
            # Remove stop words
            content_words = [word for word in words if word not in stop_words and len(word) > 2]
            
            # Subject-specific keyword weighting
            subject_keywords = {
                "math": ["equation", "formula", "calculate", "solve", "number", "algebra", "geometry", "fraction"],
                "science": ["experiment", "hypothesis", "theory", "molecule", "atom", "energy", "force", "biology"],
                "history": ["war", "battle", "empire", "revolution", "century", "ancient", "medieval", "modern"],
                "english": ["grammar", "sentence", "paragraph", "essay", "literature", "poetry", "novel", "story"],
                "geography": ["country", "continent", "ocean", "mountain", "river", "climate", "population", "capital"]
            }
            
            # Weight words based on subject relevance
            weighted_words = {}
            for word in content_words:
                weight = 1.0
                for subject, keywords in subject_keywords.items():
                    if word in keywords:
                        weight += 0.5
                weighted_words[word] = weight
            
            # Sort by weight and frequency
            word_counts = {}
            for word in content_words:
                word_counts[word] = word_counts.get(word, 0) + weighted_words.get(word, 1.0)
            
            # Get top weighted words
            sorted_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)
            top_words = [word for word, weight in sorted_words[:5]]
            
            # Create topic from top words
            if top_words:
                topic = " ".join(top_words[:3])  # Use top 3 words
            else:
                # Fallback to simple extraction
                topic = " ".join(content_words[:3]) if content_words else "general question"
            
            return topic.strip()
            
        except Exception as e:
            logger.error(f"Error in advanced topic extraction: {str(e)}")
            # Fallback to simple extraction
            words = message.lower().split()
            stop_words = {"what", "is", "are", "the", "a", "an", "in", "on", "at", "to", "for", "of", "with", "by"}
            content_words = [word for word in words if word not in stop_words]
            return " ".join(content_words[:3]) if content_words else "general question"
    
    def _analyze_question_complexity(self, message: str, grade_level: str) -> int:
        """
        Analyze question complexity using multiple factors.
        
        Args:
            message: The user's message
            grade_level: Target grade level
            
        Returns:
            Complexity score (1-10)
        """
        try:
            complexity_score = 5  # Start with medium complexity
            
            # Length-based complexity
            word_count = len(message.split())
            if word_count > 20:
                complexity_score += 1
            elif word_count < 5:
                complexity_score -= 1
            
            # Vocabulary complexity
            words = re.findall(r'\b[a-zA-Z]+\b', message.lower())
            avg_word_length = sum(len(word) for word in words) / len(words) if words else 0
            
            if avg_word_length > 6:
                complexity_score += 1
            elif avg_word_length < 4:
                complexity_score -= 1
            
            # Question type complexity
            question_indicators = {
                "what": 1, "who": 1, "when": 1, "where": 1,  # Simple factual
                "how": 3, "why": 4,  # More complex analytical
                "compare": 4, "analyze": 5, "evaluate": 5, "synthesize": 5  # High-level thinking
            }
            
            for indicator, score in question_indicators.items():
                if indicator in message.lower():
                    complexity_score = max(complexity_score, score)
            
            # Subject-specific complexity indicators
            complex_terms = [
                "relationship", "correlation", "causation", "implication", "consequence",
                "hypothesis", "theory", "principle", "concept", "methodology"
            ]
            
            for term in complex_terms:
                if term in message.lower():
                    complexity_score += 1
                    break
            
            # Adjust for grade level expectations
            try:
                target_grade = int(grade_level)
                if target_grade <= 3:
                    complexity_score = min(complexity_score, 6)  # Cap complexity for young students
                elif target_grade >= 9:
                    complexity_score = max(complexity_score, 4)  # Minimum complexity for older students
            except ValueError:
                pass
            
            return max(1, min(10, complexity_score))
            
        except Exception as e:
            logger.error(f"Error analyzing question complexity: {str(e)}")
            return 5  # Default to medium complexity
    
    def _extract_entities(self, message: str) -> List[str]:
        """
        Extract named entities and key concepts from the message.
        
        Args:
            message: The user's message
            
        Returns:
            List of extracted entities
        """
        try:
            entities = []
            
            # Simple pattern-based entity extraction
            # Numbers and dates
            numbers = re.findall(r'\b\d+(?:\.\d+)?\b', message)
            entities.extend([f"number:{num}" for num in numbers])
            
            # Capitalized words (potential proper nouns)
            proper_nouns = re.findall(r'\b[A-Z][a-z]+\b', message)
            entities.extend([f"proper_noun:{noun}" for noun in proper_nouns])
            
            # Common academic subjects
            subjects = ["math", "science", "history", "english", "geography", "biology", "chemistry", "physics"]
            for subject in subjects:
                if subject in message.lower():
                    entities.append(f"subject:{subject}")
            
            # Time-related entities
            time_words = ["today", "yesterday", "tomorrow", "week", "month", "year", "century"]
            for time_word in time_words:
                if time_word in message.lower():
                    entities.append(f"time:{time_word}")
            
            return list(set(entities))  # Remove duplicates
            
        except Exception as e:
            logger.error(f"Error extracting entities: {str(e)}")
            return []
    
    def _extract_concepts(self, message: str, syllabus: str) -> List[str]:
        """
        Extract key concepts based on the syllabus context.
        
        Args:
            message: The user's message
            syllabus: The syllabus context
            
        Returns:
            List of extracted concepts
        """
        try:
            concepts = []
            message_lower = message.lower()
            
            # Syllabus-specific concept extraction
            concept_maps = {
                "math": {
                    "arithmetic": ["add", "subtract", "multiply", "divide", "sum", "difference", "product", "quotient"],
                    "algebra": ["equation", "variable", "solve", "x", "y", "unknown", "expression"],
                    "geometry": ["triangle", "circle", "square", "rectangle", "angle", "area", "perimeter", "volume"],
                    "fractions": ["fraction", "numerator", "denominator", "half", "quarter", "third"]
                },
                "science": {
                    "biology": ["cell", "organism", "ecosystem", "evolution", "genetics", "dna", "species"],
                    "chemistry": ["atom", "molecule", "element", "compound", "reaction", "periodic", "bond"],
                    "physics": ["force", "energy", "motion", "gravity", "electricity", "magnetism", "wave"]
                },
                "history": {
                    "ancient": ["egypt", "rome", "greece", "civilization", "empire", "pharaoh", "emperor"],
                    "medieval": ["knight", "castle", "feudal", "crusade", "plague", "renaissance"],
                    "modern": ["revolution", "industrial", "world war", "democracy", "independence"]
                }
            }
            
            syllabus_lower = syllabus.lower()
            if syllabus_lower in concept_maps:
                for concept_category, keywords in concept_maps[syllabus_lower].items():
                    for keyword in keywords:
                        if keyword in message_lower:
                            concepts.append(f"{concept_category}:{keyword}")
            
            # General academic concepts
            general_concepts = {
                "analysis": ["analyze", "examine", "study", "investigate", "research"],
                "comparison": ["compare", "contrast", "similar", "different", "alike", "unlike"],
                "causation": ["cause", "effect", "result", "consequence", "because", "therefore"],
                "evaluation": ["evaluate", "assess", "judge", "critique", "opinion", "value"]
            }
            
            for concept_type, keywords in general_concepts.items():
                for keyword in keywords:
                    if keyword in message_lower:
                        concepts.append(f"thinking:{concept_type}")
                        break
            
            return list(set(concepts))  # Remove duplicates
            
        except Exception as e:
            logger.error(f"Error extracting concepts: {str(e)}")
            return []
    
    def _generate_proactive_suggestions(self, session_state: Dict[str, Any], current_topic: str, 
                                      grade_level: str, syllabus: str) -> List[str]:
        """
        Generate proactive suggestions based on conversation context and user patterns.
        
        Args:
            session_state: Current session state
            current_topic: Current topic being discussed
            grade_level: Target grade level
            syllabus: Subject context
            
        Returns:
            List of proactive suggestions
        """
        try:
            suggestions = []
            
            # Analyze user's learning patterns
            topics_explained = session_state.get("topics_explained", set())
            question_complexity = session_state.get("question_complexity", [])
            subject_interests = session_state.get("subject_interests", set())
            
            # Suggest related topics based on current discussion
            topic_relationships = {
                "fractions": ["decimals", "percentages", "ratios"],
                "algebra": ["equations", "graphing", "functions"],
                "geometry": ["area", "perimeter", "angles", "shapes"],
                "photosynthesis": ["cellular respiration", "plant biology", "ecosystems"],
                "world war": ["causes of war", "historical timeline", "geography"],
                "democracy": ["government types", "voting systems", "citizenship"]
            }
            
            current_topic_lower = current_topic.lower()
            for base_topic, related in topic_relationships.items():
                if base_topic in current_topic_lower:
                    for related_topic in related:
                        if related_topic not in [t.lower() for t in topics_explained]:
                            suggestions.append(f"Would you like to learn about {related_topic}?")
            
            # Suggest complexity progression
            if question_complexity:
                avg_complexity = sum(question_complexity[-5:]) / len(question_complexity[-5:])
                if avg_complexity < 4 and len(question_complexity) > 3:
                    suggestions.append("Ready for a more challenging question on this topic?")
                elif avg_complexity > 7:
                    suggestions.append("Would you like to review the basics of this topic?")
            
            # Suggest cross-subject connections
            cross_subject_connections = {
                "math": ["How is math used in science experiments?", "Math in art and design"],
                "science": ["The math behind scientific discoveries", "Science in everyday life"],
                "history": ["How geography influenced historical events", "Science and technology in history"]
            }
            
            syllabus_lower = syllabus.lower()
            if syllabus_lower in cross_subject_connections:
                suggestions.extend(cross_subject_connections[syllabus_lower])
            
            # Suggest study techniques based on grade level
            try:
                grade_num = int(grade_level)
                if grade_num <= 5:
                    suggestions.append("Would you like some fun ways to remember this?")
                elif grade_num >= 8:
                    suggestions.append("Want to explore real-world applications of this concept?")
            except ValueError:
                pass
            
            # Limit suggestions and add variety
            return suggestions[:3] if suggestions else []
            
        except Exception as e:
            logger.error(f"Error generating proactive suggestions: {str(e)}")
            return []
    
    def _adapt_response_style(self, session_state: Dict[str, Any], grade_level: str, 
                            question_complexity: int) -> Dict[str, Any]:
        """
        Adapt response style based on user interaction patterns.
        
        Args:
            session_state: Current session state
            grade_level: Target grade level
            question_complexity: Complexity of current question
            
        Returns:
            Style adaptation parameters
        """
        try:
            adaptation = {
                "formality_level": "medium",
                "explanation_depth": "standard",
                "use_examples": True,
                "use_analogies": False,
                "encourage_exploration": True
            }
            
            # Analyze user's response patterns
            question_count = session_state.get("question_count", 0)
            complexity_history = session_state.get("question_complexity", [])
            
            # Adapt based on grade level
            try:
                grade_num = int(grade_level)
                if grade_num <= 3:
                    adaptation.update({
                        "formality_level": "casual",
                        "explanation_depth": "simple",
                        "use_examples": True,
                        "use_analogies": True
                    })
                elif grade_num >= 9:
                    adaptation.update({
                        "formality_level": "formal",
                        "explanation_depth": "detailed",
                        "encourage_exploration": True
                    })
            except ValueError:
                pass
            
            # Adapt based on question complexity trends
            if complexity_history:
                avg_complexity = sum(complexity_history[-3:]) / len(complexity_history[-3:])
                if avg_complexity > 7:
                    adaptation["explanation_depth"] = "detailed"
                    adaptation["use_examples"] = True
                elif avg_complexity < 3:
                    adaptation["explanation_depth"] = "simple"
                    adaptation["use_analogies"] = True
            
            # Adapt based on session length
            if question_count > 10:
                adaptation["formality_level"] = "casual"  # More relaxed for longer sessions
            elif question_count < 3:
                adaptation["encourage_exploration"] = True  # Encourage new users
            
            return adaptation
            
        except Exception as e:
            logger.error(f"Error adapting response style: {str(e)}")
            return {
                "formality_level": "medium",
                "explanation_depth": "standard",
                "use_examples": True,
                "use_analogies": False,
                "encourage_exploration": True
            }
    
    def _make_autonomous_decisions(self, session_state: Dict[str, Any], current_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Make autonomous decisions about how to handle the current interaction.
        
        Args:
            session_state: Current session state
            current_context: Context of current interaction
            
        Returns:
            Dictionary of autonomous decisions
        """
        try:
            decisions = {
                "should_generate_diagram": False,
                "should_suggest_worksheet": False,
                "should_change_difficulty": False,
                "should_introduce_new_topic": False,
                "response_strategy": "direct_answer"
            }
            
            topic = current_context.get("topic", "")
            question_complexity = current_context.get("question_complexity", 5)
            entities = current_context.get("entities", [])
            concepts = current_context.get("concepts", [])
            
            # Decision: Generate diagram
            visual_indicators = ["diagram", "chart", "graph", "picture", "visual", "show me"]
            complex_topics = ["process", "cycle", "system", "structure", "relationship"]
            
            if (any(indicator in current_context.get("message", "").lower() for indicator in visual_indicators) or
                any(topic_word in topic.lower() for topic_word in complex_topics) or
                question_complexity >= 6):
                decisions["should_generate_diagram"] = True
            
            # Decision: Suggest worksheet
            topics_explained = session_state.get("topics_explained", set())
            if len(topics_explained) >= 3 and topic in topics_explained:
                decisions["should_suggest_worksheet"] = True
            
            # Decision: Change difficulty
            complexity_history = session_state.get("question_complexity", [])
            if len(complexity_history) >= 3:
                recent_avg = sum(complexity_history[-3:]) / 3
                overall_avg = sum(complexity_history) / len(complexity_history)
                
                if recent_avg > overall_avg + 2:
                    decisions["should_change_difficulty"] = "increase"
                elif recent_avg < overall_avg - 2:
                    decisions["should_change_difficulty"] = "decrease"
            
            # Decision: Response strategy
            if question_complexity <= 3:
                decisions["response_strategy"] = "simple_explanation"
            elif question_complexity >= 7:
                decisions["response_strategy"] = "detailed_analysis"
            elif any("why" in concept for concept in concepts):
                decisions["response_strategy"] = "causal_explanation"
            elif any("compare" in concept for concept in concepts):
                decisions["response_strategy"] = "comparative_analysis"
            
            # Decision: Introduce new topic
            question_count = session_state.get("question_count", 0)
            if question_count > 0 and question_count % 5 == 0:  # Every 5 questions
                decisions["should_introduce_new_topic"] = True
            
            return decisions
            
        except Exception as e:
            logger.error(f"Error making autonomous decisions: {str(e)}")
            return {
                "should_generate_diagram": False,
                "should_suggest_worksheet": False,
                "should_change_difficulty": False,
                "should_introduce_new_topic": False,
                "response_strategy": "direct_answer"
            }
    
    def _learn_from_interaction(self, session_state: Dict[str, Any], interaction_data: Dict[str, Any]):
        """
        Learn from the current interaction to improve future responses.
        
        Args:
            session_state: Current session state to update
            interaction_data: Data from the current interaction
        """
        try:
            # Update learning patterns
            topic = interaction_data.get("topic", "")
            complexity = interaction_data.get("question_complexity", 5)
            entities = interaction_data.get("entities", [])
            concepts = interaction_data.get("concepts", [])
            
            # Learn user's subject interests
            subject_interests = session_state.get("subject_interests", set())
            for entity in entities:
                if entity.startswith("subject:"):
                    subject_interests.add(entity.split(":")[1])
            session_state["subject_interests"] = subject_interests
            
            # Learn complexity preferences
            complexity_preferences = session_state.get("complexity_preferences", {})
            if topic:
                if topic not in complexity_preferences:
                    complexity_preferences[topic] = []
                complexity_preferences[topic].append(complexity)
                # Keep only recent preferences (last 5)
                complexity_preferences[topic] = complexity_preferences[topic][-5:]
            session_state["complexity_preferences"] = complexity_preferences
            
            # Learn concept relationships
            concept_relationships = session_state.get("concept_relationships", {})
            if len(concepts) > 1:
                for i, concept1 in enumerate(concepts):
                    for concept2 in concepts[i+1:]:
                        if concept1 not in concept_relationships:
                            concept_relationships[concept1] = set()
                        concept_relationships[concept1].add(concept2)
            session_state["concept_relationships"] = concept_relationships
            
            # Update success patterns
            success_patterns = session_state.get("success_patterns", {})
            response_quality = interaction_data.get("confidence_score", 0.5)
            
            pattern_key = f"complexity_{complexity}_topic_{len(topic.split())}"
            if pattern_key not in success_patterns:
                success_patterns[pattern_key] = []
            success_patterns[pattern_key].append(response_quality)
            # Keep only recent patterns
            success_patterns[pattern_key] = success_patterns[pattern_key][-10:]
            session_state["success_patterns"] = success_patterns
            
        except Exception as e:
            logger.error(f"Error learning from interaction: {str(e)}")
    
    def _check_circuit_breaker(self) -> bool:
        """
        Check if the circuit breaker allows the operation to proceed.
        
        Returns:
            True if operation can proceed, False if circuit is open
        """
        current_time = time.time()
        
        if self.circuit_breaker["state"] == "open":
            # Check if recovery timeout has passed
            if current_time - self.circuit_breaker["last_failure_time"] > self.circuit_breaker["recovery_timeout"]:
                self.circuit_breaker["state"] = "half_open"
                logger.info("Circuit breaker moved to half-open state")
                return True
            return False
        
        return True
    
    def _record_success(self):
        """Record a successful operation for circuit breaker."""
        if self.circuit_breaker["state"] == "half_open":
            self.circuit_breaker["state"] = "closed"
            self.circuit_breaker["failure_count"] = 0
            logger.info("Circuit breaker closed after successful operation")
    
    def _record_failure(self):
        """Record a failed operation for circuit breaker."""
        self.circuit_breaker["failure_count"] += 1
        self.circuit_breaker["last_failure_time"] = time.time()
        self.metrics["error_count"] += 1
        
        if self.circuit_breaker["failure_count"] >= self.circuit_breaker["failure_threshold"]:
            self.circuit_breaker["state"] = "open"
            self.metrics["circuit_breaker_trips"] += 1
            logger.warning(f"Circuit breaker opened after {self.circuit_breaker['failure_count']} failures")
    
    def _graceful_degradation_response(self, message: str, grade_level: str, syllabus: str) -> Dict[str, Any]:
        """
        Provide a graceful degradation response when primary systems fail.
        
        Args:
            message: User's message
            grade_level: Target grade level
            syllabus: Subject context
            
        Returns:
            Fallback response
        """
        self.metrics["fallback_activations"] += 1
        
        # Simple pattern-based responses for common question types
        message_lower = message.lower()
        
        fallback_responses = {
            "what": f"That's a great question about {syllabus}! Let me provide a basic explanation suitable for grade {grade_level}.",
            "how": f"Here's a simple way to think about this {syllabus} concept for grade {grade_level} level.",
            "why": f"That's an important question in {syllabus}. Let me explain the reasoning behind this concept.",
            "when": f"This is a good historical or temporal question about {syllabus}.",
            "where": f"This relates to location or context in {syllabus} studies."
        }
        
        # Find appropriate fallback response
        fallback_answer = "I understand you're asking about this topic. While I'm experiencing some technical difficulties, I want to help you learn. This appears to be a question that would benefit from a detailed explanation with examples."
        
        for question_word, response_template in fallback_responses.items():
            if question_word in message_lower:
                fallback_answer = response_template
                break
        
        return {
            "answer": fallback_answer + " I recommend asking your teacher or checking your textbook for more detailed information on this topic.",
            "diagram": None,
            "topic": "general",
            "error": "System operating in degraded mode - limited functionality available",
            "suggested_topics": ["Ask your teacher for more details", "Check your textbook", "Try rephrasing your question"],
            "confidence_score": 0.3,
            "processing_time": 0.1,
            "sources": [],
            "followup_questions": ["Would you like to try asking this question differently?"]
        }
    
    def _enhanced_error_reporting(self, error: Exception, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Provide enhanced error reporting with diagnostic information.
        
        Args:
            error: The exception that occurred
            context: Context information about the error
            
        Returns:
            Enhanced error report
        """
        error_report = {
            "error_type": type(error).__name__,
            "error_message": str(error),
            "timestamp": time.time(),
            "context": context,
            "recovery_suggestions": [],
            "user_message": "I encountered an issue while processing your request."
        }
        
        # Provide specific recovery suggestions based on error type
        if "timeout" in str(error).lower():
            error_report["recovery_suggestions"] = [
                "Try asking a simpler question",
                "Check your internet connection",
                "Wait a moment and try again"
            ]
            error_report["user_message"] = "The request took too long to process. Please try a simpler question or try again in a moment."
        
        elif "connection" in str(error).lower():
            error_report["recovery_suggestions"] = [
                "Check internet connectivity",
                "Try again in a few minutes",
                "Contact support if the issue persists"
            ]
            error_report["user_message"] = "I'm having trouble connecting to my knowledge base. Please try again in a few minutes."
        
        elif "memory" in str(error).lower() or "resource" in str(error).lower():
            error_report["recovery_suggestions"] = [
                "Try asking a shorter question",
                "Break complex questions into smaller parts",
                "Clear your session and start fresh"
            ]
            error_report["user_message"] = "Your question is quite complex. Try breaking it into smaller parts or asking a simpler question."
        
        else:
            error_report["recovery_suggestions"] = [
                "Try rephrasing your question",
                "Ask about a different topic",
                "Contact support if the issue continues"
            ]
            error_report["user_message"] = "I encountered an unexpected issue. Please try rephrasing your question or ask about a different topic."
        
        # Log detailed error information
        logger.error(f"Enhanced error report: {error_report}", exc_info=True)
        
        return error_report